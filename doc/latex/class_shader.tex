\hypertarget{class_shader}{}\section{Shader Class Reference}
\label{class_shader}\index{Shader@{Shader}}
\subsection*{Public Types}
\begin{DoxyCompactItemize}
\item 
\hypertarget{class_shader_a2ac80773f1fe928469ce4ad5f9a05035}{}enum {\bfseries Load\+Flag} \{ {\bfseries L\+O\+A\+D\+\_\+\+B\+A\+S\+I\+C} = 0, 
{\bfseries L\+O\+A\+D\+\_\+\+G\+E\+O\+M} = 0x01, 
{\bfseries L\+O\+A\+D\+\_\+\+T\+E\+S\+S} = 0x02, 
{\bfseries L\+O\+A\+D\+\_\+\+F\+U\+L\+L} = 0x03
 \}\label{class_shader_a2ac80773f1fe928469ce4ad5f9a05035}

\end{DoxyCompactItemize}
\subsection*{Public Member Functions}
\begin{DoxyCompactItemize}
\item 
\hyperlink{class_shader_a4448038b6c1f3aa797685728618c761e}{Shader} (const std\+::string \&shader\+Dir, Load\+Flag load\+Flags)
\item 
G\+Lint \hyperlink{class_shader_a2708a72dd82b3123cb77f1f1dfbbce09}{get\+Uniform\+Location} (const std\+::string \&name)
\item 
bool \hyperlink{class_shader_a71a0f88dafffbb3c3f0829e7a8c77abc}{set\+Uniform} (const std\+::string \&name, G\+Lint val)
\item 
\hypertarget{class_shader_a92000cd568b0afffce9d3b71e3953ce7}{}bool {\bfseries set\+Uniform} (const std\+::string \&name, G\+Lfloat val)\label{class_shader_a92000cd568b0afffce9d3b71e3953ce7}

\item 
\hypertarget{class_shader_a05f2c0f13bad7ade5e89dc7349f0af26}{}bool {\bfseries set\+Uniform} (const std\+::string \&name, const glm\+::vec2 \&val)\label{class_shader_a05f2c0f13bad7ade5e89dc7349f0af26}

\item 
\hypertarget{class_shader_ae3f3704fec39edddd64945711df93eb6}{}bool {\bfseries set\+Uniform} (const std\+::string \&name, const glm\+::vec3 \&val)\label{class_shader_ae3f3704fec39edddd64945711df93eb6}

\item 
\hypertarget{class_shader_a14631fcf5837fadd0ab6646338d8f11d}{}bool {\bfseries set\+Uniform} (const std\+::string \&name, const glm\+::vec4 \&val)\label{class_shader_a14631fcf5837fadd0ab6646338d8f11d}

\item 
\hypertarget{class_shader_a6bb527eba6c723f351e9427ea404f92f}{}bool {\bfseries set\+Uniform} (const std\+::string \&name, const glm\+::mat4 \&val)\label{class_shader_a6bb527eba6c723f351e9427ea404f92f}

\item 
\hypertarget{class_shader_a5e7a1c2b5e9cb47ba8f3f546e4c21081}{}{\bfseries operator G\+Luint} ()\label{class_shader_a5e7a1c2b5e9cb47ba8f3f546e4c21081}

\item 
\hypertarget{class_shader_a3ef07768420e3b9459cbe8d781868c76}{}G\+Luint {\bfseries get\+I\+D} () const \label{class_shader_a3ef07768420e3b9459cbe8d781868c76}

\end{DoxyCompactItemize}


\subsection{Constructor \& Destructor Documentation}
\hypertarget{class_shader_a4448038b6c1f3aa797685728618c761e}{}\index{Shader@{Shader}!Shader@{Shader}}
\index{Shader@{Shader}!Shader@{Shader}}
\subsubsection[{Shader(const std\+::string \&shader\+Dir, Load\+Flag load\+Flags)}]{\setlength{\rightskip}{0pt plus 5cm}Shader\+::\+Shader (
\begin{DoxyParamCaption}
\item[{const std\+::string \&}]{shader\+Dir, }
\item[{Load\+Flag}]{load\+Flags}
\end{DoxyParamCaption}
)}\label{class_shader_a4448038b6c1f3aa797685728618c761e}
Load a \hyperlink{class_shader}{Shader} from directory with the necessary files. The following naming convention is assumed\+: vertex shader\+: vert.\+glsl fragment shader\+: frag.\+glsl geometry shader\+: geom.\+glsl tesseval shader\+: eval.\+glsl tesscontrol shader\+: cont.\+glsl

These flags are used to specify the shader type\+: L\+O\+A\+D\+\_\+\+B\+A\+S\+I\+C \+: load fragment + vertex shader (always the case) L\+O\+A\+D\+\_\+\+G\+E\+O\+M \+: load geometry shader L\+O\+A\+D\+\_\+\+T\+E\+S\+S \+: load tesselation shader L\+O\+A\+D\+\_\+\+F\+U\+L\+L = L\+O\+A\+D\+\_\+\+G\+E\+O\+M $\vert$ L\+O\+A\+D\+\_\+\+T\+E\+S\+S \+: load tesselation and geometry shader


\begin{DoxyParams}{Parameters}
{\em shader\+Dir} & directory where the shader files are located \\
\hline
{\em load\+Flags} & specifies what kind of shaders should be loaded \\
\hline
\end{DoxyParams}


\subsection{Member Function Documentation}
\hypertarget{class_shader_a2708a72dd82b3123cb77f1f1dfbbce09}{}\index{Shader@{Shader}!get\+Uniform\+Location@{get\+Uniform\+Location}}
\index{get\+Uniform\+Location@{get\+Uniform\+Location}!Shader@{Shader}}
\subsubsection[{get\+Uniform\+Location(const std\+::string \&name)}]{\setlength{\rightskip}{0pt plus 5cm}G\+Lint Shader\+::get\+Uniform\+Location (
\begin{DoxyParamCaption}
\item[{const std\+::string \&}]{name}
\end{DoxyParamCaption}
)}\label{class_shader_a2708a72dd82b3123cb77f1f1dfbbce09}
Wrapper around gl\+Get\+Uniform\+Location() which also caches locations 
\begin{DoxyParams}{Parameters}
{\em name} & Name of the uniform variable \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
-\/1 if the uniform wasn\textquotesingle{}t found, else the opengl location I\+D 
\end{DoxyReturn}


Here is the caller graph for this function\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{class_shader_a2708a72dd82b3123cb77f1f1dfbbce09_icgraph}
\end{center}
\end{figure}


\hypertarget{class_shader_a71a0f88dafffbb3c3f0829e7a8c77abc}{}\index{Shader@{Shader}!set\+Uniform@{set\+Uniform}}
\index{set\+Uniform@{set\+Uniform}!Shader@{Shader}}
\subsubsection[{set\+Uniform(const std\+::string \&name, G\+Lint val)}]{\setlength{\rightskip}{0pt plus 5cm}bool Shader\+::set\+Uniform (
\begin{DoxyParamCaption}
\item[{const std\+::string \&}]{name, }
\item[{G\+Lint}]{val}
\end{DoxyParamCaption}
)}\label{class_shader_a71a0f88dafffbb3c3f0829e7a8c77abc}
Bunch of Uniform setter functions which lookup the name with gl\+Get\+Uniform\+Location(). 
\begin{DoxyParams}{Parameters}
{\em name} & Name of the uniform variable \\
\hline
{\em val} & set the uniform to this value \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
true on success, false on failure 
\end{DoxyReturn}


Here is the call graph for this function\+:\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{class_shader_a71a0f88dafffbb3c3f0829e7a8c77abc_cgraph}
\end{center}
\end{figure}




The documentation for this class was generated from the following files\+:\begin{DoxyCompactItemize}
\item 
src/shader.\+h\item 
src/shader.\+cpp\end{DoxyCompactItemize}
